#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <mono/metadata/assembly.h>
#include <mono/metadata/exception.h>

#include "driver.h"
#include "host-components.h"
#include "util.h"
#include "spin-http.h"

// These are generated by the WASI SDK during build
const char *dotnet_wasi_getentrypointassemblyname();

// Import the Mono runtime functions we need
void mono_wasm_invoke_method_ref(MonoMethod *method, MonoObject **this_arg_in, void *params[], MonoObject **_out_exc, MonoObject **out_result);
void mono_print_unhandled_exception(MonoObject *exc);

const char *initialization_error;
MonoMethod *http_handler;
int preinitialized;

spin_http_response_t internal_error(const char *message)
{
    spin_http_response_t response;
    response.status = 500;
    response.headers.is_some = false;
    response.body.is_some = true;
    response.body.val.ptr = (uint8_t *)message;
    response.body.val.len = strlen(message);
    return response;
}

void process_http_request(spin_http_request_t *req, spin_http_response_t *ret0)
{
    printf("invoking http_handler\n");
    void *method_params[] = {req};
    MonoObject *exception = NULL;
    MonoObject *result = NULL;
    mono_wasm_invoke_method_ref(http_handler, NULL, method_params, &exception, &result);

    if (exception)
    {
        mono_print_unhandled_exception(exception);
        return;
    }

    if (!result)
    {
        printf("no result\n");
        *ret0 = internal_error("no result");
        return;
    }

    spin_http_response_t *resp = mono_object_unbox(result);
    *ret0 = *resp;
}

void initialize()
{
    printf("loading runtime\n");
    mono_wasm_load_runtime("", 0);
    printf("attaching internal calls\n");
    spin_attach_internal_calls();

    printf("loading assembly\n");
    const char *assembly_name = dotnet_wasi_getentrypointassemblyname();
    MonoAssembly *assembly = mono_assembly_open(assembly_name, NULL);

    if (!assembly)
    {
        initialization_error = "Assembly not found";
        return;
    }

    printf("looking up http handler\n");
    http_handler = lookup_dotnet_method(assembly_name, "Fermyon.Spin.HelloWorld", "Handler", "HandleHttpRequest", 1);

    if (!http_handler)
    {
        initialization_error = "Method not found";
        return;
    }
}

__attribute__((export_name("wizer.initialize"))) void preinitialize()
{
    printf("preinitialize()\n");
    preinitialized = 1;
    initialize();

    if (initialization_error)
    {
        printf("initialization error: %s\n", initialization_error);
        return;
    }

    printf("calling warmup\n");
    char *warmup_url = "/warmupz";
    int warmup_url_len = strlen(warmup_url);

    // supply fake headers that would usually originate from the http trigger
    // we can't introspect on our own component config so we just make up some values
    char *fake_host = "127.0.0.1:3000";
    int fake_host_len = strlen(fake_host);
    char *warmup_url_full;
    int warmup_url_full_len = asprintf(&warmup_url_full, "http://%s%s", fake_host, warmup_url);
    spin_http_headers_t fake_headers = {.len = 10, .ptr = (spin_http_tuple2_string_string_t[]){{{"host", 4}, {fake_host, fake_host_len}}, {{"user-agent", 10}, {"wizer", 5}}, {{"accept", 6}, {"*/*", 3}}, {{"spin-full-url", 13}, {warmup_url_full, warmup_url_full_len}}, {{"spin-path-info", 14}, {warmup_url, warmup_url_len}}, {{"spin-matched-route", 18}, {"/...", 3}}, {{"spin-raw-component-route", 24}, {"/...", 3}}, {{"spin-component-route", 20}, {"", 0}}, {{"spin-base-path", 14}, {"/", 1}}, {{"spin-client-addr", 14}, {fake_host, fake_host_len}}}};

    spin_http_request_t fake_req = {
        .method = SPIN_HTTP_METHOD_GET,
        .uri = {warmup_url, warmup_url_len},
        .headers = fake_headers,
        .body = {.is_some = 1, .val = {(void *)"Hello", 5}}};
    spin_http_response_t fake_res;
    process_http_request(&fake_req, &fake_res);
}

void spin_http_handle_http_request(spin_http_request_t *req, spin_http_response_t *resp)
{
    if (!preinitialized)
    {
        initialize();
    }
    if (initialization_error)
    {
        *resp = internal_error(initialization_error);
        return;
    }
    process_http_request(req, resp);
}
